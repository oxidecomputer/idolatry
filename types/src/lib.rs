#![no_std]

//! Simple types for code generated by the Idol compiler, without any code
//! that depends on `userlib`.
//!
//! Types in this crate is re-exported by `idol-runtime`, but the crate is
//! useful on its own for Hubris crates which want to be shared with desktop
//! code.

use abi::ReplyFaultReason;

#[derive(Copy, Clone, Debug, Eq, PartialEq)]
#[repr(u32)]
pub enum ClientError {
    UnknownOperation = 0xFFFF_FE00,
    BadMessageSize = 0xFFFF_FE01,
    BadMessageContents = 0xFFFF_FE04,
    BadLease = 0xFFFF_FE02,
    ReplyBufferTooSmall = 0xFFFF_FE05,
    AccessViolation = 0xFFFF_FE06,

    /// no parallel
    WentAway = 0xFFFF_FE03,
}

/// Simple return type that is used when a function can only fail due to
/// the server dying (i.e. it will never return an error code of its own)
///
/// This should be used with the `ServerDeath` return type, which makes the
/// server-side API infallible but returns `Result<T, ServerDeath>` to the
/// client.
pub struct ServerDeath;

impl ClientError {
    pub fn into_fault(self) -> Option<ReplyFaultReason> {
        match self {
            Self::UnknownOperation => {
                Some(ReplyFaultReason::UndefinedOperation)
            }
            Self::BadMessageSize => Some(ReplyFaultReason::BadMessageSize),
            Self::BadMessageContents => {
                Some(ReplyFaultReason::BadMessageContents)
            }
            Self::BadLease => Some(ReplyFaultReason::BadLeases),
            Self::ReplyBufferTooSmall => {
                Some(ReplyFaultReason::ReplyBufferTooSmall)
            }
            Self::AccessViolation => Some(ReplyFaultReason::AccessViolation),

            // Don't fault clients that just got restarted. (Wouldn't work
            // anyway.)
            Self::WentAway => None,
        }
    }

    pub fn fail<E>(self) -> RequestError<E> {
        RequestError::Fail(self)
    }
}

impl From<ClientError> for u32 {
    fn from(x: ClientError) -> Self {
        x as u32
    }
}

#[derive(Copy, Clone, Debug, Eq, PartialEq)]
#[repr(u32)]
pub enum RequestError<E> {
    Runtime(E),
    Fail(ClientError),
}

impl<E> RequestError<E> {
    pub fn went_away() -> Self {
        Self::Fail(ClientError::WentAway)
    }

    pub fn map_runtime<T>(
        self,
        mut cvt: impl FnMut(E) -> T,
    ) -> RequestError<T> {
        match self {
            Self::Runtime(e) => RequestError::Runtime(cvt(e)),
            Self::Fail(e) => RequestError::Fail(e),
        }
    }
}

impl<E> From<E> for RequestError<E> {
    fn from(e: E) -> Self {
        Self::Runtime(e)
    }
}

/// This impl requires that E produce a u16, instead of a u32, to ensure that we
/// can zero-extend it and not conflict with any of the values of `ClientError`.
impl<E> From<RequestError<E>> for u32
where
    u16: From<E>,
{
    fn from(e: RequestError<E>) -> Self {
        match e {
            RequestError::Runtime(r) => u32::from(u16::from(r)),
            RequestError::Fail(x) => u32::from(x),
        }
    }
}
